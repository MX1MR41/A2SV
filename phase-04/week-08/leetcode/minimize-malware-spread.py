class UnionFind:
    def __init__(self, n):
        self.root = {i:i for i in range(n)}
        self.rank = defaultdict(int)
        # stores the size of the group represented by i
        self.len = {i:1 for i in range(n)}

    def find(self, x):
        if x != self.root[x]:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x, y):
        rootx, rooty = self.find(x), self.find(y)
        rankx, ranky = self.rank[x], self.rank[y]
        lenx, leny = self.len[rootx], self.len[rooty]

        if rootx != rooty:
            if rankx < ranky:
                self.root[rootx] = rooty
            elif rankx > ranky:
                self.root[rooty] = rootx
            else:
                self.root[rootx] = rooty
                self.rank[rooty] += 1

            self.len[rootx] = self.len[rooty] = lenx + leny

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # use unionfind to group connected infected nodes together 
        # choose the singular infected node which has the most members in its group
        # if no such exists, just return the smallest node

        n = len(graph)
        dsu = UnionFind(n)

        for i in range(n):
            for j in range(n):
                if i == j: continue
                if graph[i][j] == 1: dsu.union(i, j)

        # store the malwares grouped based on the set they belong to
        mals = defaultdict(list)
        for i in initial:
            rooti = dsu.find(i)
            mals[rooti].append(i)

        ans = []
        for root, mals in mals.items():
            # store alongside the total of nodes in that specific group
            ans.append([dsu.len[root], mals])

        # store the total number of nodes (N) that can be saved by removing
        # a malware infected node in saved[N]
        saved = defaultdict(list)

        max_saved = 0

        for _len, mals in ans:
            # removing this node won't save any other node 
            # since it is not the only infected node in this group
            if len(mals) > 1: 
                for i in mals:
                    saved[0].append(i)
            else: 
                # removing this node can save _len number of nodes 
                # cuz it is the only infected node in its group
                saved[_len].append(mals[0])
                max_saved = max(max_saved, _len)


        return min(saved[max_saved])
